[[Ajax]]
JavaScript, Ajax, Comet
-----------------------

This chapter's source code is: https://github.com/LiftCookbook/cookbook_ajax[https://github.com/LiftCookbook/cookbook_ajax].

For an introduction to Lift's Ajax and Comet features, read _Simply Lift_ at http://simply.liftweb.net[http://simply.liftweb.net
] or chapter 9 of _Lift in Action_ (Perrett, 2012, Manning Publications Co.).


[[ButtonTriggerServerCode]]
Trigger Server-Side Code from a Button
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to trigger some server-side code when the user presses a
button.

Solution
^^^^^^^^

Use `ajaxInvoke`:

[source,scala]
----
package code.snippet

import net.liftweb.util.Helpers._
import net.liftweb.http.SHtml
import net.liftweb.http.js.{JsCmd, JsCmds}
import net.liftweb.common.Loggable

object AjaxInvoke extends Loggable {

  def callback() : JsCmd = {
    logger.info("The button was pressed")
    JsCmds.Alert("You clicked it")
  }

  def button = "button [onclick]" #> SHtml.ajaxInvoke(callback)
}
----

In this snippet we are binding the click event of a button to an `ajaxInvoke`: when the button is pressed, Lift
arranges for the function you gave `ajaxInvoke` to be executed.

In this example, logging a message and returning a JavaScript alert to the browser. The corresponding HTML might include:

[source,html]
----
<div data-lift="AjaxInvoke.button">
  <button>Click Me</button>
</div>
----

Discussion
^^^^^^^^^^

The signature of the function you pass to `ajaxInvoke` is
`Unit => JsCmd`, meaning you can trigger a range of behaviours, from
returning `Noop` if you want nothing to happen, through changing DOM
element, all the way up to executing arbitrary JavaScript.

The example above is using a button, but will work on any element that
has an event you can bind to.  We're binding on _onclick_ but it could be any event
the DOM exposes.

Related to `ajaxInvoke` are the following functions:

* `SHtml.onEvent` which calls a function with the signature `String => JsCmd` because it
is passed the `value` of the node it is attached to. In the above
example, this would be the empty string as the button has no value.
* `SHtml.ajaxCall` which is, in a sense, more general than `onEvent`, as you give it the expression you want passed to your server-side code.
* `SHtml.jsonCall` which is even more general still: you give it a function
that will return a JSON object when executed on the client, and this
object will be passed to your server-side function.

Let's look at each of these in turn.

onEvent -- Receiving the `value` of a DOM Element
+++++++++++++++++++++++++++++++++++++++++++++++++

You can use `onEvent` with any element that has a `value` attribute and has responds to the event you choose to bind to. The function you supply to `onEvent` is called with the element's value. As an example, we can write a snippet which presents a challenge to the user, and validates the response:

[source,scala]
----
package code.snippet

import scala.util.Random
import net.liftweb.util.Helpers._
import net.liftweb.http.SHtml
import net.liftweb.http.js.JsCmds.Alert

object OnEvent {

  def render = {
    val x, y = Random.nextInt(10)
    val sum = x + y

    "p *" #> "What is %d + %d?".format(x,y) &
    "input [onchange]" #> SHtml.onEvent( answer =>
      if (answer == sum.toString) Alert("Correct!")
      else Alert("Try again")
     )
  }

}
----

This snippet prompts the user to add two random numbers in the `<p>` tag, and binds a validation function to the `<input>` on the page:

[source,html]
----
<div data-lift="OnEvent">
  <p>Problem appears here</p>
  <input placeholder="Type your answer"></input>
</div>
----

When `onchange` is triggered (by pressing return or the tab key, for example), the text entered is sent to the function as a `String`.


ajaxCall -- Receiving an Arbitrary Client-Side String
+++++++++++++++++++++++++++++++++++++++++++++++++++++

Where `onEvent` sends `this.value` to your server-side code, `ajaxCall` allows you to specify the client-side expression used to produce a value.

To demonstrate this we can create a template that includes two elements: we'll bind our function to a button, but read a value from an input field:

[source,html]
----
<div data-lift="AjaxCall">
  <input id="num" value="41"></input>
  <button>Increment</button>
</div>
----

We want to arrange for the button to read the `num` field, increment it, and return it back to the input field:

[source,scala]
----
package code.snippet

import net.liftweb.util.Helpers._
import net.liftweb.http.SHtml
import net.liftweb.http.js.JE.ValById
import net.liftweb.http.js.JsCmds._

object AjaxCall {

 def increment(in: String) : String =
  asInt(in).map(_ + 1).map(_.toString) openOr in

 def render = "button [onclick]" #>
   SHtml.ajaxCall(ValById("num"), s => SetValById("num", increment(s)) )

 }
----

The first argument to `ajaxCall` is the expression that will produce a value for our function. It can be any `JsExp`, and we've
used `ValById` which looks up the value of an element by the id attribute.  We could have used a regular JQuery expression to achieve the same effect with: `JsRaw("$('#num').val()")`.

Our second argument to `ajaxCall` takes the value of the `JsExp` expression as a `String`. We're using one of Lift's JavaScript command to replaces the value with a new value. The new value is the result of incrementing the number (providing it is a number).

The end result is that you press the button, and the number updates. It should go without saying that these are simple illustrations, and you probably don't want a server round-trip to add one to a number. The techniques come into their own when there is some action of value to perform on the server.

You may have guessed that `onEvent` is implemented as an `ajaxCall` for `JsRaw("this.value")`.


jsonCall -- Receiving a JSON Value
++++++++++++++++++++++++++++++++++

Both `ajaxCall` and `onEvent` end up evaluating a `String => JsCmd` function. With `jsonCall` the signature is `JValue => JsCmd`, meaning you can pass more complex data structures from JavaScript to your Lift application.

To demonstrate this, we'll create a template that asks for input, has a function to convert the input into JSON, and a button to send the JSON to the server:


[source,html]
----
<div data-lift="JsonCall">
  <p>Enter an addition question:</p>
  <div>
    <input id="x"> + <input id="y"> = <input id="z">.
  </div>
  <button>Check</button>
</div>

<script type="text/javascript">
// <![CDATA[
function currentQuestion() {
  return {
    first:  parseInt($('#x').val()),
    second: parseInt($('#y').val()),
    answer: parseInt($('#z').val())
  };
}
// ]]>
----

On the server we'll check that the JSON represents a valid integer addition problem:

[source,scala]
----
package code.snippet

import net.liftweb.util.Helpers._
import net.liftweb.http.SHtml
import net.liftweb.http.js.{JsCmd, JE}
import net.liftweb.common.Loggable
import net.liftweb.json.JsonAST._
import net.liftweb.http.js.JsCmds.Alert
import net.liftweb.json.DefaultFormats

object JsonCall extends Loggable {

 def render = {

  implicit val formats = DefaultFormats

  case class Question(first: Int, second: Int, answer: Int) {
   def valid_? = first + second == answer
  }

 def validate(value: JValue) : JsCmd = {
  logger.info(value)
  value.extractOpt[Question].map(_.valid_?) match {
   case Some(true) => Alert("Looks good")
   case Some(false) => Alert("That doesn't add up")
   case None => Alert("That doesn't make sense")
  }
 }

 "button [onclick]" #>
  SHtml.jsonCall( JE.Call("currentQuestion"), validate _ )
 }
}
----

Working from the bottom of this snippet up, we see a binding of the `<button>` to the `jsonCall`. The value we'll be working on is the value provided by the JavaScript function called `currentQuestion`.  This was defined on the template page.  When the button is clicked the JavaScript function is called and the resulting value will be presented to `validate`, which is our `JValue => JsCmd` function.

All `validate` does is log the JSON data and alert back if the question looks correct or not.  To do this we use the Lift JSON ability to extract JSON to a case class and call the `valid_?` test to see if the numbers add up.  This will evaluate to `Some(true)` if the addition works, `Some(false)` if the addition isn't correct or `None` if the input is missing or not a valid integer.

Running the code and entering 1, 2 and 3 into the text fields will produce the following in the server log:

[source,scala]
----
JObject(List(JField(first,JInt(1)), JField(second,JInt(2)), JField(answer,JInt(3))))
----

This is the `JValue` representation of the JSON.

See Also
^^^^^^^^

<<SelectOptionChange>> includes an example of `SHtml.onEvents` which will bind a function to a number of events on a `NodeSeq`.

For another example of `AjaxInvoke` take a look at the _Call Scala code from JavaScript_ section of Diego Medina's blog at: http://blog.fmpwizard.com/scala-lift-custom-wizard[http://blog.fmpwizard.com/scala-lift-custom-wizard].

_Exploring Lift_, chapter 10, lists various `JsExp` classes you can use for `ajaxCall`: http://exploring.liftweb.net/master/index-10.html[http://exploring.liftweb.net/master/index-10.html].



[[SelectOptionChange]]
Call Server when Select Option Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Problem
^^^^^^^

When a HTML select option is selected, you want to trigger a function on the server.


Solution
^^^^^^^^

Register a `String => JsCmd` function with `SHtml.ajaxSelect`.

In this example we will lookup the distance from Earth to a planet the user selects.  This will
happen on the server and update the browser with the result:

[source, html]
-----
 <div data-lift="HtmlSelectSnippet">
  <div>
    <label for="dropdown">Planet:</label>
    <select id="dropdown"></select>
  </div>
  <div id="distance">Distance will appear here</div>
</div>
-----

[source, scala]
-----
package code.snippet

import net.liftweb.common.Empty
import net.liftweb.util.Helpers._
import net.liftweb.http.SHtml.ajaxSelect
import net.liftweb.http.js.JsCmd
import net.liftweb.http.js.JsCmds.SetHtml
import xml.Text

class HtmlSelectSnippet {

  // Our "database" maps planet names to distances:
  type Planet = String
  type LightYears = Double

  val database = Map[Planet,LightYears](
    "Alpha Centauri Bb" -> 4.23,
    "Tau Ceti e" -> 11.90,
    "Tau Ceti f" -> 11.90,
    "Gliese 876 d" -> 15.00,
    "82 G Eridani b" -> 19.71
  )

  def render = {

    // To show the user a blank label and blank value option:
    val blankOption = ("" -> "")

    // The complete list of options includes everything in
    // our database:
    val options : List[(String,String)] =
      blankOption ::
      database.keys.map(p => (p,p)).toList

    // Nothing is selected by default:
    val default = Empty

    // The function to call when an option is picked.
    // Lookup the planet name, and return an update to the browser:
    def handler(selected: String) : JsCmd = {
      SetHtml("distance", Text(database(selected) + " light years"))
    }

    // Bind the <select> tag:
    "select" #> ajaxSelect(options, default, handler)

  }
}
-----

The last line of the code is doing the work for us.  It is generating the options and binding
the selection to a function called `handler`.  The handler function is called with the value
of the selected item.

We're using the same `String` (the planet name) for the option label and value, but they could be
different.

Discussion
^^^^^^^^^^

To understand what's going on here, take a look at the HTML that Lift produces:

[source, html]
-----
<select id="dropdown"
  onchange="liftAjax.lift_ajaxHandler('F470183993611Y15ZJU=' +
    this.options[this.selectedIndex].value, null, null, null)">
  <option value=""></option>
  <option value="Tau Ceti e">Tau Ceti e</option>
  ...
</select>
-----

The `handler` function has been stored by Lift under the identifier of "F470183993611Y15ZJU" (in this particular rendering). An "onchange" event handler is attached to the select and the function is passed the value of the selected option. The `lift_ajaxHandler` JavaScript function is defined in `liftAjax.js` which is automatically added to your page.


Collecting the Value on Form Submission
+++++++++++++++++++++++++++++++++++++++

If you need to also capture the selected value on a regular form submission, you can make use of `SHtml.onEvents`.  This attaches event listeners to a `NodeSeq`, triggering a server-side function when the event occurs.  We can use this to create a regular form with a regular select box, but wire in server-side calls when the select changes.

To make use of this, our snippet changes very little:

[source, scala]
----
var selectedValue : String = ""

"select" #> onEvents("onchange")(handler) {
  select(options, default, selectedValue = _)
} &
"type=submit" #> onSubmitUnit( () => S.notice("Destination "+selectedValue))
----

We are arranging for the same `handler` function to be called when an "onchange" event is triggered.  This event binding is applied to a regular `SHtml.select`, which is storing the `selectedValue` when the form is submitted. We also bind a submit button to a function which generates a notice of which planet was selected.

The corresponding HTML also changes little.  We need to add a button and make sure the form is marked as such:

[source,html]
----
<div data-lift="HtmlSelectFormSnippet?form=post">

  <div>
    <label for="dropdown">Planet:</label>
    <select id="dropdown"></select>
  </div>

  <div id="distance">Distance will appear here</div>

  <input type="submit" value="Book Ticket"/>

</div>
----

Now when you change a selected value you see the dynamically updated distance calculation, but pressing the "Book Ticket" button also delivers the value to the server.

See Also
^^^^^^^^

<<MultiSelectBox>> describes how to use classes rather than `String` values for select boxes.




Set up client-side actions from your Scala code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

In your Lift code you want to set up a action that is run purely in
client-side JavaScript.

Solution
^^^^^^^^

Bind the appropriate event hander with Javascript. Here's an example
where we make a button slowly fade away when you press it, but notice
that we're setting up this binding in our server-side Lift code:

[source,scala]
----
class HelloWorld {
  def buttonBind =
    "#button [onclick]" #> "$('#button').fadeOut('slow')"
}
----

In the template we'd perhaps say:

[source,html]
----
<form class="lift:HelloWorld.buttonBind">
  <input id="button" type="button" value="Click me" />
</form>
----

Lift will render the page as:

[source,html]
----
<form>
  <input onclick="$('#button').fadeOut('slow')"
    value="Click me" type="button" id="button">
</form>
----

Discussion
^^^^^^^^^^

Lift includes a JavaScript abstraction which you can use to build up
more elaborate expressions for the client-side. For example you can
combine basic commands:

[source,scala]
----
def buttonBind =
  "#button [onclick]" #> (
     Alert("Here we go...") & RedirectTo("http://liftweb.net")
    ).toJsCmd
----

...which pops up an alert dialog and then sends you to liftweb.net.
_Exploring Lift_ gives a good summary of the commands available to you.

Another option is to use `JE.Call` to execute a Javascript function with
parameters. Suppose we have this function defined:

[source,javascript]
----
function greet(who) {
  alert("Hello "+who)
}
----

We could bind a client-side button press to this client-side function
like this:

[source,scala]
----
def buttonBind =
  "#button [onclick]" #> JE.Call("greet", "you").toJsCmd
----

See Also
^^^^^^^^

* The https://groups.google.com/d/msg/liftweb/uAgy21xOMRs/bDjS69VWpp4J[mailing list discussion] that suggested this.
* http://exploring.liftweb.net/master/index-10.html#toc-Chapter-10[Chapter 10] of _Exploring Lift_.


Focus on a field on page load
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

When a page loads you want the browser to select a particular field for
input focus from the user's keyboard.

Solution
^^^^^^^^

Wrap your snippet with `FocusOnLoad`:

[source,scala]
----
import net.liftweb.http.js.JsCmds._
...
"name=username" #> FocusOnLoad(SHtml.text(username, username = _))
----

The above will match against `name="username"` element in the HTML and
replace it with a text input field that will be focused on automatically
when the page loads.

Discussion
^^^^^^^^^^

`FocusOnLoad` is an example of a `NodeSeq => NodeSeq` transformation. In
this case, it takes the result of `SHtml.text` and appends it with the
JavasScript required to set focus on that field. The example uses
`SHtml.text` but it could be any `NodeSeq`.

Related classes are:

* `Focus`, which takes an element id and sets focus on the element via a
`JsCmd`.
* `SetValueAndFocus` which is like `Focus` but takes an additional
`String` value to set on the element.

These two are useful if you need to set focus from Ajax or Comet
components, or any JavaScript Lift response.

See Also
^^^^^^^^

* http://exploring.liftweb.net/master/index-10.html#toc-Chapter-10[Lift
and JavaScript], _Exploring Lift_, chapter 10.
* http://groups.google.com/group/liftweb/browse_thread/thread/c513317f7b01b40a/a95a0426c7e17a46?lnk=gst&q=FocusOnLoad#[FocusOnLoad
for fields you're creating in a snippet]
* http://groups.google.com/group/liftweb/browse_thread/thread/541e6f3a156ccc47/fc501899e7537290?lnk=gst&q=FocusOnLoad#fc501899e7537290[FocusOnLoad
in LiftScreen]
* http://stackoverflow.com/questions/3852122/how-do-i-keep-focus-on-a-textbox-using-lift-the-scala-framework[How
do I keep focus on a textbox?]
* https://github.com/lift/framework/blob/master/web/webkit/src/main/scala/net/liftweb/http/js/JsCommands.scala[JsCommands.scala
source]

Add CSS class to an Ajax Form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to set the CSS class of an AJAX form.

Solution
^^^^^^^^

Name the class via `?class=` query parameter:

[source,html]
----
<form class="lift:form.ajax?class=myClass">
...
</form>
----

Discussion
^^^^^^^^^^

If you need to set multiple CSS classes, encode a space between the
class names, e.g., `class=myClass%20anotherClass`.

See Also
^^^^^^^^

* _Simply Lift_ on http://simply.liftweb.net/index-4.8.html[Ajax].
* Mailing list on https://groups.google.com/forum/?fromgroups#!topic/liftweb/EEINT9t8Wd4[Attaching
CSS class to ajax form using designer friendly template doesn't work].


Show a template inside a page dynamically
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to load an entire page with template and snippets inside of
another template on the fly (i.e., without a browser refresh).

Solution
^^^^^^^^

Use `Template` to load the template, and `SetHtml` to place the content
on the page.

[source,scala]
----
package code.snippet

import net.liftweb.util._
import Helpers._
import net.liftweb.http._
import js.JsCmds._

class MySnippet {

  def sendContent = Templates("some" :: "page" :: Nil).
    map(ns => SetHtml("here", ns)) openOr Noop

  def render = "name=clickme [onclick]" #> SHtml.ajaxInvoke(sendContent _)
}
----

Combine this with:

[source,html]
----
<div class="lift:MySnippet">
  <button name="clickme">Click Me</button>
  <div id="here">Content will appear here</div>
</div>
----

Clicking the button will cause the content of `/some/page.html` to be
loaded into the `here` div.

Discussion
^^^^^^^^^^

`Templates` produces a `Box[NodeSeq]`, the contents of which are mapped
to a `JsCmd` which is sent back to the browser to put the contents of
the page into the div.

See Also
^^^^^^^^

* http://scala-tools.org/mvnsites/liftweb-2.4/net/liftweb/http/js/JsCmds$$SetHtml.html[SetHtml]
documentation.
* https://groups.google.com/forum/?fromgroups#!topic/liftweb/C5UhQn5blHk[Loading Pages With Templates from Other Pages] mailing list discussion.


[[JavaScriptTail]]
Move JavaScript to End of Page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want the JavaScript created in your snippet to be included at the end of the HTML page.

Solution
^^^^^^^^

Use `S.appendJs` which places your JavaScript just before the closing `</body>` tag, along with other JavaScript produced by Lift.

In this HTML we have placed a `<script>` tag in the middle of the page, and marked it with a snippet called `JavascriptTail`:

[source,html]
-----
<!DOCTYPE html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
  <title>JavaScript in Tail</title>
</head>
<body data-lift-content-id="main">
<div id="main" data-lift="surround?with=default;at=content">
  <h2>Javascript in the tail of the page</h2>

  <script type="text/javascript" data-lift="JavascriptTail">
  </script>

  <p>
    The JavaScript about to be run will have been moved
    to the end of this page, just before the closing
    body tag.
  </p>
</div>
</body>
</html>
-----

The `<script>` content will be generated by a snippet.
It doesn't need to be a `<script>` tag: the snippet just replaces the content with nothing, but
hanging the snippet on the `<script>` tag is a reminder of the purpose of the snippet:

[source, scala]
-----
package code.snippet

import net.liftweb.util.Helpers._
import net.liftweb.http.js.JsCmds.Alert
import net.liftweb.http.S
import xml.NodeSeq

class JavascriptTail {
  def render = {
    S.appendJs(Alert("Hi"))
    "*" #> NodeSeq.Empty
  }
}
-----

Although the snippet is rendering nothing, it calls `S.appendJs` with a `JsCmd`.  This will produce the following in the page just before the end of the body:

[source, html]
-----
<script type="text/javascript">
// <![CDATA[
jQuery(document).ready(function() {
  alert("Hi");
});
// ]]>
</script>
-----

Although the snippet was in the middle of the page, the JavaScript appears at the
end of the page.


Discussion
^^^^^^^^^^

There are three other ways you could tackle this problem.  The first is to move your JavaScript to an external file, and simply include it on the page where you want it.  For substantial JavaScript code, this might make sense.

The second is a variation on `S.appendJs`: `S.appendGlobalJs` works in the same way but does not include the jQuery `ready` around your JavaScript.  This means you have no guarantee the DOM has loaded when your function is called.

A third option is wrap your JavaScript in a `<lift:tail>` snippet:

[source, scala]
-----
class JavascriptTail {
  def render =
    "*" #> <lift:tail>{Script(OnLoad(Alert("Hi")))}</lift:tail>
-----

This is a general-purpose Lift snippet and be used to move various kinds of content to the end of the page, not just JavaScript.


See Also
^^^^^^^^

<<AddToHead>> discusses a related Lift snippet for moving content to the head of the page.


