HTML
----

Generating HTML is often a major component of web applications.  This chapter is concerned with Lift's _View First_ approach and use of _CSS Selectors_.  Later chapters focus on Form processing, REST web services, and JavaScript (Ajax and Comet).

Testing and Debugging CSS Selectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to explore or debug CSS selectors interactively.

Solution
^^^^^^^^

Use the Scala REPL to run your CSS selector. From withing SBT use the `console` command to get into the REPL. Here's an example were we test out a CSS selector which applies a href to a link:

[source,scala]
----
> console             
[info] Starting scala interpreter...
[info] 
Welcome to Scala version 2.9.1.final 
Type in expressions to have them evaluated.
Type :help for more information.

scala> import net.liftweb.util.Helpers._
import net.liftweb.util.Helpers._

scala> val in = <a>click me</a>
in: scala.xml.Elem = <a>click me</a>

scala> val f = "a [href]" #> "http://example.org"
f: net.liftweb.util.CssSel = 
  (Full(a [href]), Full(ElemSelector(a,Full(AttrSubNode(href)))))

scala> f(in)
res0: scala.xml.NodeSeq = 
  NodeSeq(<a href="http://example.org">click me</a>)
----

Discussion
^^^^^^^^^^

CSS selector transforms are one of the distinguishing features of Lift. They succinctly describe a node in your template (left-hand side) and give a replacement (right-hand side). They do take a little while to get use to, so being able to test them at the Scala REPL is useful.

It may help to know that prior to CSS selectors Lift snippets were typically defined in terms
of a function that took a `NodeSeq` and returned a `NodeSeq`, often via the `bind` method.  When Lift processes such a template it knows what the input `NodeSeq` is, so it's natural to supply a function that returns a `NodeSeq`.  You won't see that usage so often any more, but the principle is the same. 

The CSS selector functionality in Lift gives you a `CssSel` function
which is `NodeSeq => NodeSeq`. We exploit this in the above example by constructing an input
`NodeSeq` (called `in`), then creating a CSS function (called `f`).  Because we know that `CssSel`
is defined as a `NodeSeq => NodeSeq` the natural way to execute the selector is to supply
the `in` as a parameter, and this gives us the answer, `res0`.

See Also
^^^^^^^^

The syntax for selectors is best described in _Simply Lift_ at http://simply.liftweb.net/index-7.10.html#toc-Section-7.10[http://simply.liftweb.net/index-7.10.html#toc-Section-7.10].

Section 6.1.2 of _Lift in Action_ also describes selectors and gives examples.


Sequencing CSS Selector Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want your CSS selector binding to apply to the results of earlier
binding expressions.

Solution
^^^^^^^^

Use `andThen` rather than `&` to compose your selector expressions. 

For example, suppose we want to replace `<div id="foo"/>` with
`<div id="bar">bar content</div>` but for some reason we needed to
generate the `bar` div as a separate step in the selector expression:

[source,scala]
----
sbt> console
[info] Starting scala interpreter...
[info] 
Welcome to Scala version 2.9.1.final (Java 1.7.0_05).
Type in expressions to have them evaluated.
Type :help for more information.

scala> import net.liftweb.util.Helpers._
import net.liftweb.util.Helpers._

scala> def render = "#foo" #> <div id="bar"/> andThen "#bar *" #> "bar content"
render: scala.xml.NodeSeq => scala.xml.NodeSeq

scala> render(<div id="foo"/>)
res0: scala.xml.NodeSeq = NodeSeq(<div id="bar">bar content</div>)
----

Discussion
^^^^^^^^^^

When using `&` think of the CSS selectors as always applying to the
original template, no matter what other expressions you are combining.
This is because `&` is aggregating the selectors together before applying them; whereas `andThen` is 
a method of all Scala functions that composes two functions together, with the fist being
called before the second.   

Compare the example above if we change the `andThen` with
`&`:

[source,scala]
----
scala> def render = "#foo" #> <div id="bar" /> & "#bar *" #> "bar content"
render: net.liftweb.util.CssSel

scala> render(<div id="foo"/>)
res1: scala.xml.NodeSeq = NodeSeq(<div id="bar"></div>)           
----

The second expression will not match as it is applied to the original
input of `<div id="foo"/>`. There's no `id="bar"` in there to match on,
so this means in the second expression adds
nothing to the `render`.

See Also
^^^^^^^^

This topic is from the Lift mailing list, and you can see the original context there:
https://groups.google.com/forum/?fromgroups#!topic/liftweb/fz3Pmlhzhfg[https://groups.google.com/forum/?fromgroups#!topic/liftweb/fz3Pmlhzhfg].



Setting Meta Tag Contents
~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to set the content of an HTML meta tag using Lift.

Solution
^^^^^^^^

Use the `@` CSS binding name selector. For example, given:

[source,html]
----
<meta name="keywords" content="words, here, please" />
----

The following snippet code will update the value of the contents
attribute:

[source,scala]
----
"@keywords [content]" #> "words, we, really, want" 
----

Discussion
^^^^^^^^^^

The `@` selector selects all elements with the given name. It's useful in this case to change `<meta name="keyword">` tag, but you may also see it used with elsewhere, for example with HTML forms to select input fields, such as `<input name="address">`.  

The `[content]` part is an example of a _replacement rule_ that can follow a selector. That's to say, it's not specific to the `@` selector and can be used with other selectors.  In this example it adds or replaces the value of the attribute called "content".

There are two other replacement rules useful for manipulating attributes: removing attributes and appending to attributes:

* `[content!]` to remove an attribute with a matching value, which in our example would be `"@keywords [content!]" #> "words, here, please"`.
* `[content+]` to append to the value, such as `"@keywords [content+]" #> ", more"`.

Although not directly relevant to `meta` tags, you should be aware of there is one convenient special case for appending to an attribute. If the attribute is `class`, a space is added together with your class value. As a demonstration of that, here's an example of appending a class called "funky" to a `div`:

[source,scala]
---------------------------------------------------------------------
scala> def render = "div [class+]" #> "funky"
render: net.liftweb.util.CssSel

scala> render(<div class="wrapper"/>)
res0: scala.xml.NodeSeq = NodeSeq(<div class="wrapper funky"></div>)
---------------------------------------------------------------------


See Also
^^^^^^^^

The syntax for selectors is best described in _Simply Lift_ at http://simply.liftweb.net/index-7.10.html[http://simply.liftweb.net/index-7.10.html].


Setting the Page Title
~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to set the `<title>` of the page from a Lift snippet.

Solution
^^^^^^^^

Select all the elements of the `title` element and replace them with the
text you want:

[source,scala]
----
"title *" #> "I am different"
----

Assuming you have a `<title>` tag in your template, the above will
result in:

[source,html]
----
<title>I am different</title>
----

Discussion
^^^^^^^^^^

It is also possible to set the page title from the contents of `SiteMap`,
meaning the title used will be the title you've assigned to the page in
the site map:

[source,html]
----
<title class="lift:Menu.title"></title>
----

The `lift:Menu.title` code appends to any existing text in the title.
This means the following will have the phrase "Site Title - " in the
title followed by the page title:

[source,html]
----
<title class="lift:Menu.title">Site Title - </title>
----

If you need more control, you can of course bind on title using a
regular snippet. This example uses a custom snippet to put the site
title after the page title:

[source,html]
----
<title class="lift:MyTitle"></title>
-----

[source,scala]
----
object MyTitle {
  def render = <title><lift:Menu.title /> - Site Title</title>
}
----

See Also
^^^^^^^^

*  _Simply Lift_ chapter 7: http://simply.liftweb.net/index-7.10.html[http://simply.liftweb.net/index-7.10.html].

* The Wiki page for SiteMap: http://www.assembla.com/spaces/liftweb/wiki/SiteMap[http://www.assembla.com/spaces/liftweb/wiki/SiteMap].

* The "dynamic titles on sitemap" mailing list discussion offers further options for computing page titles:
http://groups.google.com/group/liftweb/browse_thread/thread/e19bd2dda2b3159d[http://groups.google.com/group/liftweb/browse_thread/thread/e19bd2dda2b3159d].


Including HTML5 Shiv
~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to include HTML5 Shiv (a.k.a. HTML5 Shim) so you can use HTML5
elements with legacy IE browsers.

Solution
^^^^^^^^

Put the markup in a snippet and include the snippet in your page or
template.

[source,scala]
----
package code.snippet

import scala.xml.Unparsed

object Html5Shiv {        
  def render = Unparsed("""<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js">
  </script><![endif]-->""")
}
----

Reference the snippet in the `<head>` of your
`templates-hidden/default.html`, e.g.,:

[source,html]
----
<script class="lift:Html5Shiv"></script>
----

Discussion
^^^^^^^^^^

The HTML5 parser used by Lift does not carry comments from the source
through to the rendered page. If you just tried to paste the html5shim markup into 
your template you'd find it missing from the rendered page.

We deal with this by generating unparsed markup from a snippet. If you're looking at 
`Unparsed` and worried, your instincts are correct.  Normally Lift would cause the
markup to be escaped, but in this case we really do want
unparsed XML content (the comment tag) included in the output. 

See Also
^^^^^^^^

If you're doing a lot of IE conditional includes, take a look at the mailing list
suggestion from Antonio Salazar Cardozo for using a IE confitional comment snippet: https://groups.google.com/d/msg/liftweb/kLzcJwfIqHQ/K91MdtoNz0MJ[https://groups.google.com/d/msg/liftweb/kLzcJwfIqHQ/K91MdtoNz0MJ].

The html5shim project can be found at: http://code.google.com/p/html5shim/[http://code.google.com/p/html5shim/].


Returning Snippet Markup Unchanged
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want a snippet to return the original markup associated with the
snippet invocation.

Solution
^^^^^^^^

Use the `PassThru` transform. For
example, suppose you have a snippet which performs a transforms when some
condition is met, but if the condition is not met, you want the snippet
return the original markup.

Starting with the original markup...

[source,html]
----
<div class="myclass"> 
  <p>Nothing to worry about</p> 
</div>
----

...we could leave it alone or change it with this snippet:

[source,scala]
----
def render = if (someCondition)
    ".myclass *" #> <p>The condition happened</p>
  else
    PassThru
----

Discussion
^^^^^^^^^^

`PassThru` is a `NodeSeq => NodeSeq` function that returns the input it
is given (an identity function).  It's defined as:

-----
object PassThru extends Function1[NodeSeq, NodeSeq] {
  def apply(in: NodeSeq): NodeSeq = in
}
-----

The pattern of converting one `NodeSeq` to another is simple, but also powerful enough to get you out of most situations as you can always arbitrarily re-write the `NodeSeq`.


See Also
^^^^^^^^

* The _How
to return the original markup associated with snippet invocation?_ mailing list discussion: https://groups.google.com/d/msg/liftweb/A69tyIBBSdg/mUGO6_qUFqwJ[https://groups.google.com/d/msg/liftweb/A69tyIBBSdg/mUGO6_qUFqwJ]

* Take a look at the source for `PassThru`, which is at https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/CssSel.scala[https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/CssSel.scala], to see how this and other similar functions are defined. 


Snippet Not Found when using HTML5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You're using Lift with the HTML5 parser and one of your snippets,
perhaps `<lift:HelloWorld.howdy />`, is rendering with a "Class Not
Found" error.

Solution
^^^^^^^^

Switch to the designer-friendly snippet invocation mechanism. E.g.,

[source,html]
----
<div class="lift:HellowWorld.howdy">...</div>
----

Discussion
^^^^^^^^^^

The HTML5 parser and the traditional Lift XHTML parser have different
behaviours. In particular the HTML5 parser converts elements and attribute names to lower
case when looking up snippets. This means Lift would take `<lift:HelloWorld.howdy />` and look for a class called "helloworld" rather than "HelloWorld", which would be the cause of the "Class Not Found Error".

Switching to the designer-friendly mechnism is the solution here, and you gain validating HTML as a bonus.

In this text we use the HTML5 parser, which is set in `Boot.scala`:

[source,scala]
-----
// Use HTML5 for rendering
LiftRules.htmlProperties.default.set( (r: Req) => 
  new Html5Properties(r.userAgent) )
----


See Also
^^^^^^^^

The key differences between the XHTML and HTML5 parser are outlined on the mailing list at https://groups.google.com/d/msg/liftweb/H-xe1uRLW1c/B60UH8P54VAJ[https://groups.google.com/d/msg/liftweb/H-xe1uRLW1c/B60UH8P54VAJ].



Avoiding CSS and JavaScript Caching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You've modified CSS or JavaScript in your application, but web browsers
have cached your resources and are using the older versions. You'd like
to avoid this browser caching.

Solution
^^^^^^^^

Add the `lift:with-resource-id` class attribute to script or link tags:

[source,html]
----
<script class="lift:with-resource-id" src="/myscript.js" 
 type="text/javascript"></script>
----

The addition of this class will cause Lift to append a "resource id" to
your `src` (or `href`), and as this resource id changes each time Lift
starts, it defeats browser caching.

The resultant HTML might be:

[source,html]
----
<script src="/myscript.js?F619732897824GUCAAN=_" 
  type="text/javascript" ></script>
----

Discussion
^^^^^^^^^^

The randome value that is appended to the resource is computed when your Lift application boots.  This means it should be stable between releases of your application.

If you need some other behaviour from `with-resource-id` you can assign
a new function of type `String => String` to
`LiftRules.attachResourceId`. The default implementation, shown above,
takes the resource name ("/myscript.js" in the example) and returns the
resource name with an id appended. 

You can also wrap a number of tags inside a
`<lift:with-resource-id>...<lift:with-resource-id>` block. However,
avoid doing this in the `<head>` of your page as the HTML5 parser will
move the tags to be outside of the head section.

Note that some proxies may choose not to cache resources with query
parameters at all. If that impacts you, it's possible to code a custom resource id method
to move the random resouce ID out of the query parameter and into the path.

Here's one approach to doing this. Rather than generate JavaScript and CSS links that look like `/myscript.js?F61973`, we will generate `/cache/F61973/myscript.js`. We then will need to tell Lift to take requests 
that look like this new format, and render the correct content for the request.  This all happens in `Boot.scala`:

[source, scala]
-----------
// The random number we're using to avoid caching
val resourceId = Helpers.nextFuncName

// Prefix lift:with-resource-id links with "/cache/{resouceId}"
LiftRules.attachResourceId = (path: String) => {
  "/cache/" + resourceId + path
}

// The resource suffix we're caching: ".js" or ".css" 
object CacheableExt {
  def unapply(s: String): Option[String] = s match {
    case "js" | "css" => Some(s)
    case _ => None
  }
}

// Remove the cache/{resourceId} from the request if there is one
LiftRules.statelessRewrite.prepend( NamedPF("BrowserCacheAssist") {
  case RewriteRequest( 
    ParsePath("cache" :: id :: file, CacheableExt(suffix), _,_), _, _) => 
    RewriteResponse(file.init ++ List(file.last+"."+suffix), Map[String,String]())
})
-----------

The `statelessRewrite` is a little long, but it's doing quite a lot.  First, it's matching only 
request that start with "cache", followed by some value, followed by a filename, where the suffix
of the file matches the `CacheableExt`.  If it does, we reconstruct the path without the caching part.


See Also
^^^^^^^^

The source for `LiftRules` shows the default implementation of `attachResourceId`: https://github.com/lift/framework/blob/master/web/webkit/src/main/scala/net/liftweb/http/LiftRules.scala[https://github.com/lift/framework/blob/master/web/webkit/src/main/scala/net/liftweb/http/LiftRules.scala].

Google's _Optimize caching_ notes are a good source of information about browser behaviour: https://developers.google.com/speed/docs/best-practices/caching[https://developers.google.com/speed/docs/best-practices/caching].


Adding to the Head of a Page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You use a template for layout, but on one specific page you need to add
something to the `<head>` section.

Solution
^^^^^^^^

Use the `lift:head` snippet or CSS class so Lift knows to merge the
contents with the `<head>` of your page. For example, suppose you have
the following contents in `templates-hidden/default.html`:

[source,html]
----
<html lang="en" xmlns:lift="http://liftweb.net/"> 
  <head> 
    <meta charset="utf-8"></meta> 
    <title class="lift:Menu.title">App: </title>
    <script id="jquery" src="/classpath/jquery.js" 
      type="text/javascript"></script>
    <script id="json" src="/classpath/json.js" 
      type="text/javascript"></script>
 </head>
 <body>
     <div id="content">The main content will get bound here</div>
 </body>
</html>
----

Also suppose you have `index.html` on which you want to include `my.css`
just for that page. Do so by including the CSS in the part of the page
that will get processed and mark it for the head with `lift:head`:

[source,html]
-----
<!DOCTYPE html>
<html>
 <head>
   <title>Special</title>
 </head>
 <body class="lift:content_id=main">
  <div id="main" class="lift:surround?with=default;at=content">
   <link class="lift:head" rel="stylesheet" href="/my.css" type='text/css'>
   <h2>Hello</h2>
  </div>
 </body>
</html>
-----

Note that this `index.html` page is validated HTML5, and will produce a
result with the custom CSS inside the `<head>` tag, something like this:

[source,html]
----
<!DOCTYPE html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <title>App:  Home</title>
  <script type="text/javascript" 
    src="/classpath/jquery.js" id="jquery"></script>
  <script type="text/javascript" 
    src="/classpath/json.js" id="json"></script>
  <link rel="stylesheet" href="/my.css" type="text/css">
 </head>
 <body>
   <div id="main">
     <h2>Hello</h2>
   </div>
  <script type="text/javascript" src="/ajax_request/liftAjax.js"></script>
  <script type="text/javascript"> 
  // <![CDATA[
  var lift_page = "F557573613430HI02U4";
  // ]]>
  </script>
 </body>
</html>
----

Discussion
^^^^^^^^^^

If you find your tags not appearing the the `<head>` section, check that
the HTML in your template and page is valid HTML5.

You can also use `<lift:head>...</lift:head>` to wrap a number of
expressions, and will see `<head_merge>...</head_merge>` used in code
example as an alternative to `<lift:head>`.

You may also see `data-lift="head"` is also used as an alternative to
`class="lift:head"`.

See Also
^^^^^^^^

* Mailing list discussion on _Designer Friendly Way of Head Merge_ at https://groups.google.com/d/msg/liftweb/rG_pOXdp4Ew/cPHTyTDhmWEJ[https://groups.google.com/d/msg/liftweb/rG_pOXdp4Ew/cPHTyTDhmWEJ].

* The W3C HTML validator is a useful tool for tracking down HTML markup issues that may cause problems with content being moved into the head of your page. http://validator.w3.org/[http://validator.w3.org/]. 



Custom 404 Page
~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to show a customised "404" (page not found) page.

Solution
^^^^^^^^

In `Boot.scala` add the following:

[source,scala]
----
LiftRules.uriNotFound.prepend(NamedPF("404handler"){
  case (req,failure) => 
    NotFoundAsTemplate(ParsePath(List("404"),"html",false,false))
})
----

The file `src/main/webapp/404.html` will now be served for requests to
unknown resources.

Discussion
^^^^^^^^^^

The `uriNotFound` Lift rule needs to return a `NotFound` in reply to a
`Req` (request) and optional `Failure`. This allows you to customise the
response based on the type of failure or the request that was made.

There are three types of `NotFound`:

* `NotFoundAsTemplate` is useful to invoke the Lift template processing
facilities from a `ParsePath`.
* `NotFoundAsResponse` allows you to return a specific `LiftResponse`.
* `NotFoundAsNode` wrappers a `NodeSeq` for Lift to translate into a 404
response.

In case you're wondering, the two `false` arguments to `ParsePath`
indicates the path we've given isn't absolute, and doesn't end in a
slash.

See Also
^^^^^^^^

The Wiki entry for this topic: http://www.assembla.com/spaces/liftweb/wiki/Custom_404_-_URI_not_found_page


Other Custom Status Pages
~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to show a customised page for certain HTTP status codes.

Solution
^^^^^^^^

Use `LiftRules.responseTransformers` to match against the response and
supply an alternative.

For example, suppose we want to provide a customised page for 403
("Forbidden") statuses created in your Lift application. In `Boot.scala`
we could add the following:

[source,scala]
----
LiftRules.responseTransformers.append {
  case r if r.toResponse.code == 403 => RedirectResponse("/403.html")
  case r => r
}
----

The file _src/main/webapp/403.html_ will now be served for requests that
generate 403 status codes. Other, non 403, requests are left untransformed.

Discussion
^^^^^^^^^^

`LiftRules.responseTransformers` allows you to supply
`LiftResponse => LiftResponse` functions to change a response at the end
of the HTTP processing cycle. This is a very general mechanism: in this
example we are matching on a status code, but we could match on anything
exposed by `LiftResponse`. 

We've shown a `RedirectResponse` being
returned but there are many different kinds of `LiftResponse` we could
send to the client.

One way to test the above example is to add the following to Boot to
make all requests to _/secret_ return a 403:

[source,scala]
----
val Protected = If(() => false, () => ForbiddenResponse("no way"))

val entries = List(
  Menu.i("Home") / "index", 
  Menu.i("secret") / "secret" >> Protected,
  Menu.i("403") / "403" >> Hidden 
  // rest of your site map here...
)
----

If you request _/secret_, a 403 response will be triggered, which will match the response transformer showing you
the _403.html_ page.

See Also
^^^^^^^^

_The Request/Response Lifecycle_ section in _Exploring Lift_ in gives more details about the processing pipeline. 
http://exploring.liftweb.net/master/index-9.html#toc-Section-9.2[http://exploring.liftweb.net/master/index-9.html#toc-Section-9.2
].


Links in Notices
~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to include a clickable link in your `S.error`, `S.notice` or
`S.warning` messages.

Solution
^^^^^^^^

Include a `NodeSeq` containing a link in your notice:

[source,scala]
----
S.error("checkPrivacyPolicy", 
  <span>See our <a href="/policy">privacy policy</a></span>)
----

You might pair this with the following in your template:

[source,html]
---------------------------------------------------------
<div class="lift:Msg?id=checkPrivacyPolicy"></div>
---------------------------------------------------------

See Also
^^^^^^^^

Lift notices are described on the Wiki: http://www.assembla.com/spaces/liftweb/wiki/Lift_Notices_and_Auto_Fadeout[http://www.assembla.com/spaces/liftweb/wiki/Lift_Notices_and_Auto_Fadeout].


Rendering Textile Markup
~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

You want to render Textile markup in your web app.

Solution
^^^^^^^^

Install the Lift Textile module in your `build.sbt` file by adding the
following to the list of dependencies:

[source,scala]
----
"net.liftmodules" %% "textile" % (liftVersion + "1.1") % "compile->default",
----

You can then use the module to render Textile using the `toHtml` method:

[source,scala]
---------------------------------------------------------
scala> import net.liftmodules.textile._                   
import net.liftmodules.textile._

scala> TextileParser.toHtml("""h1. Hi!              
 | 
 | The module in "Lift":http://www.liftweb.net for turning Textile markup 
 | into HTML is pretty easy to use.
 | 
 | * As you can see
 | * in this example
 |""")
res0: scala.xml.NodeSeq = 
NodeSeq(<h1>Hi!</h1>, 
, <p>The module in <a href="http://www.liftweb.net">Lift</a> for turning 
Textile markup into HTML is pretty easy to use.</p>, 
, <ul><li> As you can see</li>
<li> In this example</li>
</ul>, 
, )
---------------------------------------------------------

Discussion
^^^^^^^^^^

There's nothing special code has to do to become a Lift module, although there are common conventions: they typically are packaged as _net.liftmodules_, but don't have to be; they usually depend on a version of Lift; they sometimes use the hooks provided by `LiftRules` to provide a particular behaviour.  Anyone can create and publish a Lift module, and anyone can contribute to existing modules. In the end, they are declared as dependencies in SBT, and pulled into your code just like any other dependency.

image::images/moduleversioning.png[]

The dependency version is made up of two elements: the Lift version, and the module version. This is because modules have their own release cycle, so you could have versions 1.1, 1.2 and 1.3 all for the same version of Lift. However, they may also depend on certain features of Lift, hence the combined version number.


See Also
^^^^^^^^

* There's no real specification of what Textile is, but there are references available which cover the typical kinds of mark up to enter and what HTML you can expect to see: http://redcloth.org/hobix.com/textile/[http://redcloth.org/hobix.com/textile/].

* _Lift in Action_, chapter 7 contains a Wiki example that uses the
Textile plugin.

* The home of the Textile module: https://github.com/liftmodules/textile[
https://github.com/liftmodules/textile].

* The unit tests for the Textile module give you a good set of examples of what is supported: https://github.com/liftmodules/textile/blob/master/src/test/scala/net/liftmodules/textile/TextileSpec.scala[https://github.com/liftmodules/textile/blob/master/src/test/scala/net/liftmodules/textile/TextileSpec.scala].

* http://www.liftmodules.net[http://www.liftmodules.net] describes the module system in Lift.


